#
# Copyright (c) 2010-2013 LAAS/CNRS
# All rights reserved.
#
# Redistribution  and  use  in  source  and binary  forms,  with  or  without
# modification, are permitted provided that the following conditions are met:
#
#   1. Redistributions of  source  code must retain the  above copyright
#      notice and this list of conditions.
#   2. Redistributions in binary form must reproduce the above copyright
#      notice and  this list of  conditions in the  documentation and/or
#      other materials provided with the distribution.
#
# THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
# WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
# MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
# ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
# WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
# IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
#                                           Anthony Mallet on Tue Jan 12 2010
#

# Template for type mappings generation.

template usage "Mappings generation template\n" [regsub -all [join {
  { *#/? ?} {@(b|code){([^{}]*)}} {@itemx?([^\n]*)\n} {@(genom){([^{}]*)}}
  {@(quotation|example|table|var|end)[^\n]*\n} {@([@{}])}
} |] {
  #/ This template generates a source file containing the native type
  # definitions for all IDL types defined in the .gen input file. By default,
  # types are generated for the codels language (defined in the .gen
  # file). This can be changed with the -l option (several -l options can be
  # given, for multiple mappings generation). The generated files are named
  # after the component name, that is suffixed with _types. The suffix can be
  # changed with the -s option. The source files are generated in the current
  # directory by default (see -C option for changing the output directory).
  #
  # Additionnaly, a dependency file suitable for inclusion in a @code{Makefile}
  # can be generated. This is controlled by the @code{-MD}, @code{-MF} and
  # @code{-MT} options. These options are documented herafter, and follow the
  # same syntax as the same options of @code{gcc}.
  #
  # @b{Example:}
  # @example
  # user@@host:~$ genom3 mappings demo.gen
  # creating ./demo_c_types.h
  # user@@host:~$ genom3 mappings -l c++ demo.gen
  # creating ./demo_cxx_types.h
  # @end example
  #
  # @b{Supported options:}
  # @quotation
  # @table @code
  # @item -l
  # @itemx --language=lang
  #	Generate mappings for language
  # @item -s
  # @itemx --suffix=string
  #	Set output file name suffix
  # @item --signature
  #		Generate codel signatures and types mappings
  # @item -MD
  #			Generate dependency information (in out.d)
  # @item -MF=file
  #		Generate dependency in file instead of out.d
  # @item -MT=target
  #		Change the target of the dependency rules
  # @item -C
  # @item --directory=dir
  #	Output files in dir instead of current directory
  # @item -p
  # @itemx --preserve
  #		Do not overwrite existing files
  # @item -m
  # @itemx --modify
  #		Overwrite files even if they did not change
  # @item -h
  # @itemx --help
  #		Print usage summary (this text)
  # @end table
  # @end quotation
} {\2\3\4\7}]

# defaults
variable dir		.
variable suffix		_types
variable sign		[list]
variable deps		off
variable dfile		"out.d"
variable dtarget	""
engine mode +overwrite +move-if-change

# parse options
template options {
	 --signature	{ set sign [list file codels.h] }
    -s - --suffix	{ set suffix [template arg] }
    -l - --language	{ lappend lang [template arg] }
    -MD			{ set deps on }
    -MF			{ set dfile [template arg] }
    -MT			{ set dtarget [template arg] }
    -C - --directory	{ set dir [template arg] }
    -p - --preserve	{ engine mode -overwrite }
    -m - --modify	{ engine mode -move-if-change }
    -h - --help		{ puts [template usage]; exit 0 }
}

# check/process input files
if {![llength $argv]} { puts [template usage]; exit 2 }
foreach f $argv { dotgen parse file $f }
engine chdir $dir

# generate header
set header " Generated by [dotgen genom version]. Do not edit.\n"
append header " Source file: $argv\n"
if {![catch {dotgen input notice} notice]} {
  append header $notice
}

# generate types definitions
set out [list]
foreach c [dotgen components] {
    if {[info exists lang]} { set l $lang } else { set l [$c language] }
    foreach l $l {
      lang $l
      set filen [string map {+ x} $l]
      template parse					\
          args [list $c $l]				\
          raw [comment $header]\n			\
          string [language mapping]			\
          {*}$sign					\
          file "[$c name]_${filen}$suffix[fileext header]"
      lappend out "[$c name]_${filen}$suffix[fileext header]"
    }
}

# dependencies
if {$dtarget == ""} { set dtarget $out }
if {$deps} {
  set deps [list]
  foreach d [concat [dotgen input deps] [template deps]] {
    lappend deps "$dtarget: $d"
    lappend deps "$d:"
  }
  engine mode +overwrite -move-if-change
  template parse raw [join $deps "\n"]\n file $dfile
}
