#
# Copyright (c) 2010 LAAS/CNRS
# All rights reserved.
#
# Redistribution  and  use  in  source  and binary  forms,  with  or  without
# modification, are permitted provided that the following conditions are met:
#
#   1. Redistributions of  source  code must retain the  above copyright
#      notice and this list of conditions.
#   2. Redistributions in binary form must reproduce the above copyright
#      notice and  this list of  conditions in the  documentation and/or
#      other materials provided with the distribution.
#
# THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
# WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
# MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
# ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
# WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
# IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
#                                           Anthony Mallet on Fri Jan  8 2010
#

namespace eval template {

    # default template options: just -h
    variable options {
	-h - --help {
	    template fatal "no options available for this template"
	}
    }

    # default usage message
    variable usage "Supported options:\n  -h.--help\t\tprint usage summary"

    # set to 1 when options have been parsed
    variable gotopt	0

    # save template options
    variable args [set ::argv]


    # --- require ----------------------------------------------------------

    # \proc template require {\em file}
    # \index template require
    #
    # Source tcl {\em file} and make its content available to the template
    # files. The file name can be absolute or relative. If it is relative, it
    # is interpreted as relative to the template directory (see {\tt dotgen
    # template dir}).
    #
    # \arg file	Tcl input file to source. Any procedure that it creates is
    #		made available to the template files.
    #
    proc require { src } {
	set src [file join [dotgen template dir] $src]
	puts "sourcing $src"

	if {[catch {
	    source $src
	    slave invokehidden source $src
	} m]} {
	    template fatal "$m"
	}
    }
    namespace export require


    # --- parse ------------------------------------------------------------

    # \proc template parse [args {\em list}] [file/string/raw {\em file} ...]
    # \index template parse
    #
    # This is the main template function that parses a template source file and
    # instanciate it, writing the result into the current template
    # directory (or in a global variable). This procedure should be invoked for
    # each source file that form a template.
    #
    # When invoking {\tt template parse}, the last two arguments are the
    # destination file or string. A destination file is specified as {\tt file
    # {\em file}} (the filename is relative to the current template output
    # directory). Alternatively, a destination string is specified as {\tt
    # string {\em var}}, where {\em var} is the name of a {\em global} variable
    # in which the template engine will store the result of the source
    # instantiation.
    #
    # The output destination file or string is generated by the template from
    # one or several input source. An input source is typically a source file,
    # but it can also be a string or a raw (unprocessed) text. An input source
    # file is specified with {\tt file {\em file}}, where {\em file} is a file
    # name relative to the template directory. An input source read from a
    # string is specified as {\tt string {\em text}}, where text is any string,
    # processed by the template engine as usual. Finally, a raw, unprocessed
    # source that is copied verbatim to the destination, is specified as {\tt
    # raw {\em text}}, where {\em text} is any string.
    #
    # Additionnaly, each input source, defined as above, can be passed a list
    # of optional arguments by using the special {\tt args {\em list}}
    # construction as the first argument of the {\tt template parse}
    # command. The list given after {\tt args} can be retrieved from the
    # template source file from the usual {\tt argv} variable.
    #
    # \begin{description}
    # \item[Examples:]
    # {\tt template parse file mysrc file mydst}
    #
    # Will parse the input file {\tt mysrc}, process it and save the result in
    # {\tt mydst}.
    #
    # {\tt template parse args \{one two\} file mysrc file mydst}
    #
    # Will do the same as above, but the template code in the input file {\tt
    # mysrc} will have the list \{one two\} accessible via the {\tt argv}
    # variable.
    #
    # {\tt template parse string "test" file mydst}
    #
    # Will process the string "test" and save the result in {\tt mydst}.
    # \end{description}
    #
    # \arg args	This optional argument should be followed by a list of
    #		arguments to pass to the template source file. It should be the
    #		very first argument, otherwise it is ignored. Each element of
    #		the list is available from the template source file in the {\tt
    #		argv} array.
    #
    proc parse { args } {
	if {[llength $args] < 4 || [llength $args] % 2} {
	    template fatal "wrong # args"
	}

	# process options, if not done already
	getopt

	# produce output
	lassign [lrange $args end-1 end] dtype dst
	set out [engine::open $dtype $dst write]

	set savedargs [engine::args [list]]
	foreach { stype src } [lrange $args 0 end-2] {
	    switch -- $stype {
		args	{ engine::args $src }

		raw {
		    set in [engine::open string $src read]
		    if {[catch {chan copy $in $out} m]} {
			template fatal "$m"
		    }
		    engine::close $in
		}

		string  -
		file	{
		    set in [engine::open $stype $src read]
		    if {$stype == "string"} { set src "<string>" }
		    if {[catch {engine::process $src $in $out} m]} {
			engine::close $in
			template message $m
			exit 2
		    }
		    engine::close $in
		}

		default {
		    engine::close $out
		    template fatal \
			"unknown source '$stype': must be args, string or file"
		}
	    }
	}
	engine::args $savedargs

	engine::close $out
	return
    }
    namespace export parse


    # --- link -------------------------------------------------------------

    # \proc template link {\em src} {\em dst}
    # \index template link
    #
    # Link source file {\em src} to destination file {\em dst}. If relative,
    # the source file {\em src} is interpreted as relative to the template
    # directory and {\em dst} is interpreted as relative to the current output
    # directory. Absolute file name can be given to override this behaviour.
    #
    proc link { src dst } {
	set src [file join [dotgen template dir] $src]
	set dst [file join [engine pwd] $dst]
	if {[file normalize $src] == [file normalize $dst]} return

	if {[file exists $dst]} {
	    if {[lsearch [engine mode] move-if-change] >= 0} {
		set d [file normalize [file link $dst]]
		set s [file normalize $src]
		if {$s == $d} {
		    template message "$dst is up-to-date"
		    return
		}
	    }
	    if {[lsearch [engine mode] -overwrite] >= 0} {
		template fatal "file $dst would be overwritten"
		return
	    }

	    template message "overwriting $dst"
	    file delete $dst
	} else {
	    template message "creating link $dst"
	}

	file mkdir [file dirname $dst]
	file link $dst $src
	return
    }
    namespace export link


    # --- options ----------------------------------------------------------

    # \proc template options \{ pattern body ... \}
    # \index template options
    #
    # Define the list of supported options for the template. Argument is a
    # Tcl switch-like script that must define all supported options. It
    # consists of pairs of {\em pattern body}. If an option matching the {\em
    # pattern} is passed to the template, the {\em body} script is evaluated. A
    # special body specified as "-" means that the body for the next pattern
    # will be used for this pattern.
    #
    # \begin{description}
    # \item[Examples:]
    # {\tt template options \{\par -h - --help	\{ puts "help option" \}\par \}}
    #
    # This will make the template print the text "help option" whenever -h or
    # --help option is passed to the template.
    # \end{description}
    #
    proc options { ospec } {
	variable options
	variable gotopt

	if {$gotopt} {
	    fatal "options specification must be set before any"	\
		"'template parse' command"
	}

	if {[llength $ospec] % 2} { fatal "invalid options specification" }
	lappend ospec -h - --help { template fatal "help not implemented" }

	set options $ospec

	# process options, if not done already
	getopt
    }
    namespace export options


    # --- arg --------------------------------------------------------------

    # \proc template arg
    # \index template arg
    #
    # Return the next argument passed to the template, or raise an error is
    # no argument remains.
    #
    proc arg { } {
	global argc argv

	set optarg [lindex $argv 1]
	if {$optarg == ""} {
	    template fatal "missing argument to [lindex $argv 0]"
	}

	set argv [lreplace $argv 1 1]
	incr argc -1
	return $optarg
    }
    namespace export arg


    # --- usage ------------------------------------------------------------

    # \proc template usage [{\em string}]
    # \index template usage
    #
    # With a {\em string} argument, this procedure defines the template "usage"
    # message. Unless the template redefines a {\tt -h} option with {\tt
    # template options}, the default behaviour of the template is to print the
    # content of the {\tt template usage} string when -h or --help option is
    # passed to the template.
    #
    # {\tt template usage}, when invoked without argument, returns the last
    # usage message defined.
    #
    proc usage { args } {
	variable usage

	if {[llength $args] == 0} { return $usage }
	set usage [join $args {}]
	return
    }
    namespace export usage


    # --- message ----------------------------------------------------------

    # \proc template message [{\em string}]
    # \index template message
    #
    # Print {\em string} so that it is visible to the end-user. The text is
    # sent on the standard error channel unconditionnaly.
    #
    proc message { m } {
	puts stderr $m
    }
    namespace export message


    # --- fatal ------------------------------------------------------------

    # \proc template fatal [{\em string}]
    # \index template fatal
    #
    # Print an error message and stop. In verbose mode, print the source
    # location as reported by [info frame].
    #
    proc fatal { args } {
	set info [info frame -1]
	set l ""
	if {[dict exists $info file]} {
	    append l "[file tail [dict get $info file]]:"
	    if {[dict exists $info line]} {
		append l "[dict get $info line]:"
	    }
	    append l " "
	}
	if {[dict exists $info proc]} {
	    append l "in [dict get $info proc]"
	}
	return -code error -level 2 -errorinfo "[join $args]\n    $l" \
	    [join $args]
    }
    namespace export fatal


    # --- getopt -----------------------------------------------------------

    # Parse options according to the template specification.
    #
    proc getopt { } {
	variable gotopt
	if {$gotopt} { return } else { set gotopt 1 }

	global argc argv
	variable usage
	variable options

	# process options
	while {$argc > 0} {
	    incr argc -1
	    set arg [lindex $argv 0]
	    if {[regexp -- {(--?.+)=(.+)} $arg m o a]} {
		set arg $o
		set argv [linsert $argv 1 $a]
	    }

	    uplevel #0 switch -glob -- $arg [concat $options * "{
		template fatal \"unknown option $arg\"
	    }"]

	    set argv [lrange $argv 1 end]
	}

	# process extraneous arguments
	if {$argc > 0} {
	    message "too many arguments -- $argv"
	    fatal $usage
	}

	return
    }

    namespace ensemble create
}
