/* GenoM objects parsing test */

/*/
 * Copyright (c) 2010 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution  and  use  in  source  and binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 * THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
 * WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
 * MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
 * ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
 * WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *                                           Anthony Mallet on Sun Jan 24 2010
 */

enum e1 { ee1, ee2, ee3 };

typedef sequence<string<28>, 10> x;

component c {
  version:	"1.0";
  email:	"null@example.com";
  lang:		"c";

  require:	"a", "b", "c";
  build-require:"d", "e";
};

ids {
  long a;
  struct str {
    long a;
    long b;
    struct sub {
      long d;
    } c;
  } b[3];
  e1 c;
  string d;
  string<128> e;
  long f[3];
  sequence<sequence<long> > g;
  sequence<long,128> h;
};

attribute a = 0 :: "first attribute", b;
attribute d = "none";

inport data<long> a;
outport data<c::ids::str> b;
inport event<> c;

task t1;

task t2 {
  period:	5ms;
  delay:	3ms;
  priority:	100;
  scheduling:	real-time;
  stack:	20k;

  codel start, stop:
   a(inport a, outport b.b::port) yield sleep, stop;
  codel stop: b(in b[2].c.d::input, inout b[0].a::inout, out ::ids) yield ether;
  codel stop: c(in d, out e) yield ether;

  throw:	ERR1, ERR2;
};

service s1() {
  doc: "service s1";
};

service s2(
	   in ::p1 = { .a = 2 ::"long doc", {
	       [2] = { .b = 2, .a = 4, .c = { 2 } }
	     }, ee1} :: "also doc",
	   in a = 2 :: "long doc",
	   in b[2].c.d::b = :: "long doc",
	   in d = "test string" :: "a string",
	   in f, in g,
	   out e, out c, out f::outf, out h) {
  doc: "service s2";
  task: t1;

  validate: v(in b[0].c::a, out c);

  codel start: a(inport a, outport b.b::port) yield sleep, ether;
  codel stop: b(in b[2].c.d::input, inout b[0].a::inout, out ::ids) yield ether;
  codel stop: c(in f, out f::outf) yield ether;
  codel stop: d(in g, out h) yield ether;

  throw:	ERR3;
  interrupts:	all;
  after:	s1;
};
