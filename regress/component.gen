/* GenoM objects parsing test */

/*/
 * Copyright (c) 2010 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution  and  use  in  source  and binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 * THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
 * WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
 * MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
 * ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
 * WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *                                           Anthony Mallet on Sun Jan 24 2010
 */

enum e1 { ee1, ee2, ee3 };

struct ids {
  long a;
  struct str {
    long a;
    long b;
    struct sub {
      long d;
    } c;
  } b[3];
  e1 c;
};

component c {
  ids:		ids;
  version:	"1.0";
  email:	"null@example.com";
  lang:		"c";

  require:	"a", "b", "c";
  build-require:"d", "e";
};

inport long a;
outport ids::str b;
event c;

task t1;

task t2 {
  period:	5ms;
  delay:	3ms;
  priority:	100;
  stack:	20k;

  codel start, stop:
   a(inport a, outport b.b::port) yield sleep, stop;
  codel stop: b(in b[2].c.d::input, inout b[0].a::inout, out ::ids) yield ether;

  throws:	ERR1, ERR2;
};

service s1() {
  doc: "service s1";
  task: control;
};

service s2(
	   in ::p1 = { .a = 2 ::"long doc", {
	       [2] = { .b = 2, .a = 4, .c = { 2 } }
	     }, ee1} :: "also doc",
	   in a = 2 :: "long doc",
	   out c,
	   outport b
	   ) {
  doc: "service s2";
  task: t1;

  validate: v(in b[0].c::a, out c);

  codel start: a(inport a, outport b.b::port) yield sleep, ether;
  codel stop: b(in b[2].c.d::input, inout b[0].a::inout, out ::ids) yield ether;

  throws:	ERR3;
  interrupts:	all;
  after:	s1;
};
