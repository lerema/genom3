#!/bin/sh
. ${0%${0##*/}}../test.sh

# minimalistic .gen file
cat >run.gen <<'EOF'
EOF
mkdir -p run.t


# --- language fileext c ---------------------------------------------------
#
testing '[fileext]'

run 0 ${GENOM_BIN} interactive -b run.gen <<EOF
lang c
puts [fileext]
puts [fileext source]
puts [fileext header]
EOF
expect out '/^\.c|\.h$/ {next}; {exit 2}'


# --- language comment c ---------------------------------------------------
#
testing '[comment]'

run 0 ${GENOM_BIN} interactive -b run.gen <<EOF
lang c
puts [comment comment]
EOF
expect out '/^\/\*comment\*\/$/ {next}; {exit 2}'


# --- language mapping c ---------------------------------------------------
#
testing '[language mapping]'

run 0 ${GENOM_BIN} interactive -b ${0%${0##*/}}../datatypes.gen <<'EOF'
lang c
puts [language mapping]
puts "int main() { return 0; }\n"
EOF
expect out ''
mv -f run.out run.t/mapping.c
run 0 ${CC} -I${top_srcdir}/runtime run.t/mapping.c


# --- language declarator c ------------------------------------------------
#
testing '[language declarator]'

run 0 ${GENOM_BIN} interactive -b ${0%${0##*/}}../datatypes.gen <<'EOF'
lang c
puts [[dotgen type ::xlong] decl a]
puts [[dotgen type ::xlongarray] decl a]
puts [[dotgen type ::xbstring] decl a]
EOF
expect out '
	/^xlong a$/ {next}
	/^xlongarray a$/ {next}
	/^xbstring a$/ {next}
	{exit 2}
'


# --- language member c ----------------------------------------------------
#
testing '[language member]'

cat >run.gen <<'EOF'
component c {
  ids {
    struct ss {
      long a;
    } a[2];
  };
  attribute s() { validate: c(in a[1].a); };
};
EOF

run 0 ${GENOM_BIN} interactive -b run.gen <<'EOF'
lang c
set p [[[[dotgen component] service] validate] parameter]
puts [$p member]
EOF
expect out '
	/^.a\[1\]\.a$/ {next}
	{exit 2}
'


# --- language cname c -----------------------------------------------------
#
testing '[cname]'

cat >run.gen <<'EOF'
struct s {
  struct ss {
    long a;
  } a;
};
component c {
  task t {
    codel x: tcodel() yield ether;
  };
  activity s() {
    task: t;
    codel x: scodel() yield ether;
  };
};
EOF

run 0 ${GENOM_BIN} interactive -b run.gen <<'EOF'
lang c
puts 1,[cname [[dotgen type ::s::ss::a] fullname]]
puts 2,[cname [[lindex [[dotgen component] task] 0] codel]]
puts 3,[cname [[[dotgen component] service] codel]]
EOF
expect out '
	/^1,s_ss_a$/ {next}
	/^2,tcodel$/ {next}
	/^3,scodel$/ {next}
	{exit 2}
'


# --- language signature c -------------------------------------------------
#
testing '[language signature]'

cat >run.gen <<'EOF'
component comp {
  task t;
  ids { short a, b; };
  port in comp::ids a;
  port out comp::ids b;
  port handle in comp::ids ah;
  port handle out comp::ids bh;
  port handle in comp::ids aha[];
  port handle out comp::ids bha[];
  activity s(in long a, out long b) {
    task: t;
    codel c: c(service in a, service out b) yield d;
    codel d: d(ids in a::a1, ids out b::b1) yield e;
    codel e: e(port in a::a2, port out b::b2) yield f;
    codel f: f(port in ah::a3) yield g;
    codel g: g(port out bh::b3) yield h;
    codel h: h(port in aha::a4) yield i;
    codel i: i(port out bha::b4) yield c;
  };
};
EOF
run 0 ${GENOM_BIN} interactive -b run.gen <<'EOF'
lang c
foreach c [[[dotgen component] service] codels] {
  puts [$c signature -sep-]
}
EOF
expect out '
	/^comp_event-sep-c\(const int32_t \*a, int32_t \*b\)$/ {next}
	/^comp_event-sep-d\(const int16_t \*a1, int16_t \*b1\)$/ {next}
	/^comp_event-sep-e\(const comp_ids \*a2, comp_ids \*b2\)$/ {next}
	/^comp_event-sep-f\(genom_port_handle \*a3\)$/ {next}
	/^comp_event-sep-g\(genom_port_handle \*b3\)$/ {next}
	/^comp_event-sep-h\(genom_port_handle_set \*a4\)$/ {next}
	/^comp_event-sep-i\(genom_port_handle_set \*b4\)$/ {next}
	{exit 2}
'


# --- language invoke c ----------------------------------------------------
#
testing '[language invoke]'

cat >run.gen <<'EOF'
component c {
  attribute s() {
    validate: codel();
  };
};
EOF
run 0 ${GENOM_BIN} interactive -b run.gen <<'EOF'
lang c
set c [[[dotgen component] service] validate]
puts [$c invoke {}]
EOF
expect out '
	/^codel\(\)$/ {next}
	{exit 2}
'
