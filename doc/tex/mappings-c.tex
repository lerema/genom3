%
% Copyright (c) 2009-2010 LAAS/CNRS
% All rights reserved.
%
% Permission to use, copy, modify, and distribute this software for any purpose
% with or without   fee is hereby granted, provided   that the above  copyright
% notice and this permission notice appear in all copies.
%
% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
% REGARD TO THIS  SOFTWARE INCLUDING ALL  IMPLIED WARRANTIES OF MERCHANTABILITY
% AND FITNESS. IN NO EVENT SHALL THE AUTHOR  BE LIABLE FOR ANY SPECIAL, DIRECT,
% INDIRECT, OR CONSEQUENTIAL DAMAGES OR  ANY DAMAGES WHATSOEVER RESULTING  FROM
% LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION,   ARISING OUT OF OR IN    CONNECTION WITH THE USE   OR
% PERFORMANCE OF THIS SOFTWARE.
%
%                                             Anthony Mallet on Fri Jun 25 2010
%

\subsection{Scoped names}

The {\tt C} mappings always use the  global name for a type or a constant.  The
{\tt C} global  name corresponding to a \GenoM{} IDL global  name is derived by
converting  occurrences of  "::" to  "\_" (an  underscore) and  eliminating the
leading underscore.


\subsection{Mapping for constants}

In {\tt C}, constants defined in dotgen are {\tt \#define}d. For instance, the
following IDL:
\begin{verbatim}
      const long longint = 1;
      const string str = "string example";
\end{verbatim}

would map into
\begin{verbatim}
      #define longint 1
      #define str "string example"
\end{verbatim}

The  identifier can  be referenced  at any  point in  the user's  code  where a
literal of that type is legal.


\subsection{Mapping for basic data types}

The     basic     data     types     have     the     mappings     shown     in
\xref[table:mapping:cbasic]{Table~\ref{table:mapping:cbasic}}.   Integer  types
use the  {\tt C99} fixed size integer  types as provided by  the {\tt stdint.h}
standard header. Users do not have to include this header: the template mapping
generation  procedure output  the appropriate  {\tt \#include}  directive along
with the mappings for the integer types.

\begin{table}
\centering
\begin{tabular}{|ll|}
\doublehline
{\tt\bfseries IDL} & {\tt\bfseries C}\\
\hline
\tt boolean              & \tt bool\\
\tt unsigned short       & \tt uint16\_t\\
\tt short                & \tt int16\_t\\
\tt unsigned long        & \tt uint32\_t\\
\tt long                 & \tt int32\_t\\
\tt unsigned long long   & \tt uint64\_t\\
\tt long long            & \tt int64\_t\\
\tt float                & \tt float\\
\tt double               & \tt double\\
\tt char                 & \tt char\\
\tt octet                & \tt uint8\_t\\
\tt any                  & type any not implemented yet\\
\hline
\end{tabular}
\caption{Basic data types C mappings}
\label{table:mapping:cbasic}
\end{table}


\subsection{Mapping for enumerated types}

The C mapping of an IDL {\tt enum} type is an unsigned, $32$ bits wide integer.
Each  enumerator in an  enum is  {\tt \#define}d  with an  appropriate unsigned
integer  value  conforming  to  the  ordering constraints.

For instance, the following IDL:
\begin{verbatim}
      enum e {
         value1,
         value2
      };
\end{verbatim}

would map, according to the scoped names rules, into
\begin{verbatim}
      typedef uint32_t e
      #define e_value1  1
      #define e_value2  2
\end{verbatim}


\subsection{Mapping for strings}

\GenoM{}  IDL bounded  strings are  mapped to  nul terminated  character arrays
(i.e., C strings). Unbounded strings are mapped to a pointer on such a
character array.

For instance, the following OMG IDL declarations:
\begin{verbatim}
      typedef string unbounded;
      typedef string<16> bounded;
\end{verbatim}

would map into
\begin{verbatim}
      typedef char *unbounded;
      typedef char bounded[16];
\end{verbatim}


\subsection{Mapping for arrays}

\GenoM{} IDL arrays map directly to C arrays. All array indices run from 0 to
{\tt size-1}.

For instance, the following IDL:
\begin{verbatim}
      typedef long array[4][16];
\end{verbatim}

would map into
\begin{verbatim}
      typedef int32_t array[4][16];
\end{verbatim}


\subsection{Mapping for structure types}

\GenoM{}  IDL structures map  directly onto  C {\tt  struct}s. Note  that these
structures  may  potentially  include  padding.

For instance, the following IDL:
\begin{verbatim}
      struct s {
         long a;
         long b;
      };
\end{verbatim}

would map into
\begin{verbatim}
      typedef struct {
         int32_t a;
         int32_t b;
      } s;
\end{verbatim}


\subsection{Mapping for union types}

\GenoM{}  IDL unions map onto  C {\tt  struct}s. The discriminator in the enum
is referred to as {\tt \_d}, the union itself is referred to as {\tt \_u}.

For instance, the following IDL:
\begin{verbatim}
      union u switch(long) {
         case 1: long a;
         case 2: float b;
         default: char c;
      };
\end{verbatim}

would map into
\begin{verbatim}
      typedef struct {
         int32_t _d;
         union {
            int32_t a;
            float b;
            char c;
         } _u;
      } u;
\end{verbatim}


\subsection{Mapping for sequence types}

\GenoM{}  IDL  sequences  mapping  differ  slightly  for  bounded  or  unbouded
variations of the sequence. Both types maps  onto a C {\tt struct}, with a {\tt
\_maximum}, {\tt \_length} and {\tt \_buffer} members.

For  unbounded sequences,  {\tt buffer}  points  to a  buffer of  at most  {\tt
\_maximum} elements and containing {\tt \_length} valid elements. An additional
member {\tt  \_release} is a function pointer  that can be used  to release the
storage  associated  to  the  {\tt  \_buffer}  and reallocate  it.  It  is  the
responsibility of the user to maintain the consistency between those members.

For bounded  sequences, {\tt  buffer} is  an array of  at most  {\tt \_maximum}
elements and containing {\tt \_length}  valid elements. Since {\tt \_buffer} is
an array, no memory management is necessary for this data type.

For instance, the following IDL:
\begin{verbatim}
      typedef sequence<long> unbounded;
      typedef sequence<long,16> bounded;
\end{verbatim}

would map into
\begin{verbatim}
      typedef struct {
         uint32_t _maximum, _length;
         int32_t *_buffer;
         void (*release)(void *_buffer);
      } unbounded;

      typedef struct {
         const uint32_t _maximum;
         uint32_t _length;
         int32_t _buffer[16];
      } bounded;
\end{verbatim}
