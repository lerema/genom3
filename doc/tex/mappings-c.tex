%
% Copyright (c) 2009-2010 LAAS/CNRS
% All rights reserved.
%
% Permission to use, copy, modify, and distribute this software for any purpose
% with or without   fee is hereby granted, provided   that the above  copyright
% notice and this permission notice appear in all copies.
%
% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
% REGARD TO THIS  SOFTWARE INCLUDING ALL  IMPLIED WARRANTIES OF MERCHANTABILITY
% AND FITNESS. IN NO EVENT SHALL THE AUTHOR  BE LIABLE FOR ANY SPECIAL, DIRECT,
% INDIRECT, OR CONSEQUENTIAL DAMAGES OR  ANY DAMAGES WHATSOEVER RESULTING  FROM
% LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION,   ARISING OUT OF OR IN    CONNECTION WITH THE USE   OR
% PERFORMANCE OF THIS SOFTWARE.
%
%                                             Anthony Mallet on Fri Jun 25 2010
%

\subsection{Scoped names}

The {\tt C} mappings always use the  global name for a type or a constant.  The
{\tt C} global  name corresponding to a \GenoM{} IDL global  name is derived by
converting  occurrences of  "::" to  "\_" (an  underscore) and  eliminating the
leading underscore.


\subsection{Mapping for constants}

In {\tt C}, constants defined in dotgen are {\tt \#define}d. For instance, the
following IDL:\hfill\\
\verb|      const long longint = 1;|\hfill\\
\verb|      const string str = "string example";|\hfill\\
would map into\hfill\\
\verb|      #define longint 1|\hfill\\
\verb|      #define str "string example"|\hfill\\

The  identifier can  be referenced  at any  point in  the user's  code  where a
literal of that type is legal.


\subsection{Mapping for basic data types}

The     basic     data     types     have     the     mappings     shown     in
\xref[table:mapping:cbasic]{Table~\ref{table:mapping:cbasic}}.   Integer  types
use the  {\tt C99} fixed size integer  types as provided by  the {\tt stdint.h}
standard header. Users do not have to include this header: the template mapping
generation  procedure output  the appropriate  {\tt \#include}  directive along
with the mappings for the integer types.

\begin{table}
\caption{Basic data types C mappings}
\centering
\begin{tabular}{|ll|}
\doublehline
{\tt\bfseries IDL} & {\tt\bfseries C}\\
\hline
\tt boolean              & \tt bool\\
\tt unsigned short       & \tt uint16\_t\\
\tt short                & \tt int16\_t\\
\tt unsigned long        & \tt uint32\_t\\
\tt long                 & \tt int32\_t\\
\tt unsigned long long   & \tt uint64\_t\\
\tt long long            & \tt int64\_t\\
\tt float                & \tt float\\
\tt double               & \tt double\\
\tt char                 & \tt char\\
\tt octet                & \tt uint8\_t\\
\tt any                  & type any not implemented yet\\
\hline
\end{tabular}
\label{table:mapping:cbasic}
\end{table}


\subsection{Mapping for enumerated types}

The C mapping of an IDL {\tt enum} type is an unsigned, $32$ bits wide integer.
Each  enumerator in an  enum is  {\tt \#define}d  with an  appropriate unsigned
integer  value  conforming  to  the  ordering constraints.

For instance, the following IDL:\hfill\\
\verb|      enum e {|\hfill\\
\verb|         value1,|\hfill\\
\verb|         value2|\hfill\\
\verb|      };|\hfill\\

would map, according to the scoped names rules, into\hfill\\
\verb|      typedef uint32_t e|\hfill\\
\verb|      #define e_value1  1|\hfill\\
\verb|      #define e_value2  2|\hfill\\


\subsection{Mapping for strings}

\GenoM{}  IDL bounded  strings are  mapped to  nul terminated  character arrays
(i.e., C strings). Unbounded strings are mapped to a pointer on such a
character array.

For instance, the following OMG IDL declarations:\hfill\\
\verb|      typedef string unbounded;|\hfill\\
\verb|      typedef string<16> bounded;|\hfill\\

would map into\hfill\\
\verb|      typedef char *unbounded;|\hfill\\
\verb|      typedef char bounded[16];|\hfill\\


\subsection{Mapping for arrays}

\GenoM{} IDL arrays map directly to C arrays. All array indices run from 0 to
{\tt size-1}.

For instance, the following IDL:\hfill\\
\verb|      typedef long array[4][16];|\hfill\\

would map into\hfill\\
\verb|      typedef int32_t array[4][16];|\hfill\\


\subsection{Mapping for structure types}

\GenoM{}  IDL structures map  directly onto  C {\tt  struct}s. Note  that these
structures  may  potentially  include  padding.

For instance, the following IDL:\hfill\\
\verb|      struct s {|\hfill\\
\verb|         long a;|\hfill\\
\verb|         long b;|\hfill\\
\verb|      };|\hfill\\

would map into\hfill\\
\verb|      typedef struct {|\hfill\\
\verb|         int32_t a;|\hfill\\
\verb|         int32_t b;|\hfill\\
\verb|      } s;|\hfill\\


\subsection{Mapping for union types}

\GenoM{}  IDL unions map onto  C {\tt  struct}s. The discriminator in the enum
is referred to as {\tt \_d}, the union itself is referred to as {\tt \_u}.

For instance, the following IDL:\hfill\\
\verb|      union u switch(long) {|\hfill\\
\verb|         case 1: long a;|\hfill\\
\verb|         case 2: float b;|\hfill\\
\verb|         default: char c;|\hfill\\
\verb|      };|\hfill\\

would map into\hfill\\
\verb|      typedef struct {|\hfill\\
\verb|         int32_t _d;|\hfill\\
\verb|         union {|\hfill\\
\verb|            int32_t a;|\hfill\\
\verb|            float b;|\hfill\\
\verb|            char c;|\hfill\\
\verb|         } _u;|\hfill\\
\verb|      } u;|\hfill\\


\subsection{Mapping for sequence types}

\GenoM{}  IDL  sequences  mapping  differ  slightly  for  bounded  or  unbouded
variations of the sequence. Both types maps  onto a C {\tt struct}, with a {\tt
\_maximum}, {\tt \_length} and {\tt \_buffer} members.

For  unbounded sequences,  {\tt buffer}  points  to a  buffer of  at most  {\tt
\_maximum} elements and containing {\tt \_length} valid elements. An additional
member {\tt  \_release} is a function pointer  that can be used  to release the
storage  associated  to  the  {\tt  \_buffer}  and reallocate  it.  It  is  the
responsibility of the user to maintain the consistency between those members.

For bounded  sequences, {\tt  buffer} is  an array of  at most  {\tt \_maximum}
elements and containing {\tt \_length}  valid elements. Since {\tt \_buffer} is
an array, no memory management is necessary for this data type.

For instance, the following IDL:\hfill\\
\verb|      typedef sequence<long> unbounded;|\hfill\\
\verb|      typedef sequence<long,16> bounded;|\hfill\\

would map into\hfill\\
\verb|      typedef struct {|\hfill\\
\verb|         uint32_t _maximum, _length;|\hfill\\
\verb|         int32_t *_buffer;|\hfill\\
\verb|         void (*release)(void *_buffer);|\hfill\\
\verb|      } unbounded;|\hfill\\
\verb||\hfill\\
\verb|      typedef struct {|\hfill\\
\verb|         const uint32_t _maximum;|\hfill\\
\verb|         uint32_t _length;|\hfill\\
\verb|         int32_t _buffer[16];|\hfill\\
\verb|      } bounded;|\hfill\\
