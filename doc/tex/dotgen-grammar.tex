%
% Copyright (c) 2009-2010 LAAS/CNRS
% All rights reserved.
%
% Permission to use, copy, modify, and distribute this software for any purpose
% with or without   fee is hereby granted, provided   that the above  copyright
% notice and this permission notice appear in all copies.
%
% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
% REGARD TO THIS  SOFTWARE INCLUDING ALL  IMPLIED WARRANTIES OF MERCHANTABILITY
% AND FITNESS. IN NO EVENT SHALL THE AUTHOR  BE LIABLE FOR ANY SPECIAL, DIRECT,
% INDIRECT, OR CONSEQUENTIAL DAMAGES OR  ANY DAMAGES WHATSOEVER RESULTING  FROM
% LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION,   ARISING OUT OF OR IN    CONNECTION WITH THE USE   OR
% PERFORMANCE OF THIS SOFTWARE.
%
%                                             Anthony Mallet on Mon May 31 2010
%

This chapter describes the \GenoM{} Input File Format (dotgen) semantics and
gives the syntax for dotgen grammatical constructs.

\section{Overview}
\index{input!file format}

The \GenoM{}  Input File Format (\I{dotgen})  is the language  used to formally
describe a \GenoM{} component in terms  of services and data types it provides.
A  description written  in  dotgen  completely defines  the  interface and  the
internals of a component.

A    description    of   the    dotgen    preprocessing    is   presented    in
\xref[sec:iff:preproc]{section~\ref{sec:iff:preproc}}.     The    grammar    is
presented    in    \xref[sec:iff:grammar]{section~\ref{sec:iff:grammar}}    and
associated semantics is  described in the rest of this  chapter either in place
or through references to other sub sections of this chapter.

A source  file containing a dotgen  component specification must  have a ".gen"
extension. The description of the dotgen grammar uses a syntax notation that is
similar        to       Extended        Backus-Naur        Format       (EBNF).
\xref[table:iff:ebnf]{Table~\ref{table:iff:ebnf}}  lists  the  symbols used  in
this format and their meaning.

\begin{table}
\caption{dotgen EBNF symbols}
\centering
\begin{tabular}{|cl|}
\doublehline
Symbol & Meaning\\
\hline
::=                     & Definition.\\
\verb#|#                & Alternation.\\
text                    & Nonterminals.\\
"text"                  & Terminals.\\
( \ldots )              & Grouping.\\
\{ \ldots \}            & Repetition: may occur zero or any number of times.\\
\verb#[#\ldots\verb#]#  & Option: may occur zero or one time.\\
\hline
\end{tabular}
\label{table:iff:ebnf}
\end{table}

\section{Preprocessing}
\label{sec:iff:preproc}\index{input!preprocessing}

A dotgen specification consists of one or more files that are preprocessed. The
\I{preprocessing}  performs  file  inclusion  and  macro  substitution  and  is
controlled  by directives  introduced by  lines having  {\tt \#}  as  the first
character  other  than  white  space.   The  preprocessing is  done  by  the  C
preprocessor available  on the host system  and configured during  the build of
\GenoM{}. It is invoked as a separate process.

Preprocessor directives beginning with {\tt  \#} have their own syntax (namely,
the  C  preprocessor  syntax),  independent  of the  dotgen  language  and  not
described   in  this   document.    See  for   instance~\cite{cpp|fsf}  for   a
documentation.  Directives may  appear anywhere in the source  file but are not
seen  nor  interpreted by  \GenoM{}.   The  primary  use of  the  preprocessing
facilities is  to include definitions (especially type  definitions) from other
dotgen specifications.  Text in files included with a {\tt \#include} directive
is treated as if it appeared in the including file.

\section{Dotgen grammar}
\label{sec:iff:grammar}\index{dotgen!grammar}

\input{dotgen-rules}

\section{Dotgen specification}
\label{sec:iff:dgspec}\index{dotgen!specification}

A  dotgen specification  consists of  one  or more  statements. Statements  are
either IDL statements,  \GenoM{} statements or cpp line  directives. The syntax
is:

\smallbreak
\input{dotgen-rule-spec}
\input{dotgen-rule-statement}
\input{dotgen-rule-idlstatement}
\input{dotgen-rule-genomstatement}

Definitions    are     named    be    the    mean     of    identifiers:    see
\xref[sec:iff:identifier]{section~\ref{sec:iff:identifier}}.       Cpp     line
directives are normally issued by the C preprocessor and are used to define the
current        input       file        name        and       line        number
(\xref[sec:iff:cpphash]{section~\ref{sec:iff:cpphash}}).

An          IDL          statement          defines         types          (see
\xref[sec:iff:type]{section~\ref{sec:iff:type}}),         constants        (see
\xref[sec:iff:const]{section~\ref{sec:iff:const}})  or  IDL modules  containing
types and  constants (see \xref[sec:iff:module]{section~\ref{sec:iff:module}}).
The syntax follows  closely the subset the OMG  IDL specification corresponding
to    type     and    constants    definitions     (see    Part~I,    chapter~7
of~\cite{omg|corba31}).  Note that this subset  of the dogten grammar is not in
any manner tied to OMG IDL and may diverge from future OMG specifications.

A  \GenoM{} statement  defines  components, communication  ports, services  and
execution contexts called tasks.


\section{Identifiers and reserved keywords}
\label{sec:iff:identifier}\index{dotgen!identifier}

An  \I{identifier} is  a sequence  of ASCII  alphabetic, digit,  and underscore
("\_") characters.  The first character must be an ASCII alphabetic character.

\smallbreak\input{dotgen-rule-identifier}

Words that are  reserved keywords in the dotgen  language are valid identifiers
where their use is not ambiguous.


\section{Line directives}
\label{sec:iff:cpphash}

Line directives  are normally not used.  They  are inserted by {\tt  cpp}, as a
result of  preprocessing the input  file (section~\ref{sec:iff:preproc}).  They
can be used mostly to achieve special effects on error reporting or similar.

A line directive starts with the \# sign:

\smallbreak\input{dotgen-rule-cpphash}

The \# sign is followed by the  current line number and file name of the source
file,  optionally  followed by  a  numeric  flag. The  flag  is  never used  by
\GenoM{}.  Its meaning depends  on the  C preprocessor  used: see  for instance
chapter 1.8, C preprocessor output, of the FSF C preprocessor~\cite{cpp|fsf}.

The file  name and  line number  replace the current  value kept  internally by
\GenoM{}  and are  used in  error reporting  messages as  well as  a  few other
places.


\section{Module declaration}
\label{sec:iff:module}

A module definition satisfies the following syntax:

\smallbreak
\input{dotgen-rule-module}
\input{dotgen-rule-module_name}
\input{dotgen-rule-idldef}
\input{dotgen-rule-idlspec}

The only effect of a module is to scope IDL identifiers. It is similar to a C++
or  Java  namespace;  it is  considered  good  practice  to enclose  your  type
definitions  inside  a  module  definition  to  prevent  name  clashes  between
components.


\section{Type declaration}
\label{sec:iff:type}

Type declarations  define new data types  and associate a  name (an identifier)
with it. The  {\tt typedef} keyword can  be used to name an  existing type. The
constructed types {\tt  struct}, {\tt union} and {\tt enum}  also name the type
they define. The syntax is the following:

\smallbreak
\input{dotgen-rule-type_dcl}
\input{dotgen-rule-constructed_type}
\input{dotgen-rule-alias_list}
\bigbreak

A type specification is the description of a type. It can be used in a {\tt
typedef} construct or anywhere a typed value is expected.

\smallbreak
\input{dotgen-rule-type_spec}
\input{dotgen-rule-simple_type_spec}
\input{dotgen-rule-base_type_spec}
\input{dotgen-rule-template_type_spec}
\input{dotgen-rule-constructed_type_spec}
\input{dotgen-rule-named_type}
\input{dotgen-rule-scoped_name}
\input{dotgen-rule-declarator}
\input{dotgen-rule-simple_declarator}


\section{Constant declaration}
\label{sec:iff:const}

\smallbreak\input{dotgen-rule-const_dcl}
