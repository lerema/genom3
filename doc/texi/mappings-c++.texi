@c
@c Copyright (c) 2009-2013 LAAS/CNRS
@c All rights reserved.
@c
@c Permission to use, copy, modify,  and distribute this software for any
@c purpose with or without fee is hereby granted, provided that the above
@c copyright notice and this permission notice appear in all copies.
@c
@c THE  SOFTWARE  IS  PROVIDED  "AS  IS" AND  THE  AUTHOR  DISCLAIMS  ALL
@c WARRANTIES  WITH  REGARD  TO   THIS  SOFTWARE  INCLUDING  ALL  IMPLIED
@c WARRANTIES  OF MERCHANTABILITY  AND  FITNESS. IN  NO  EVENT SHALL  THE
@c AUTHOR BE  LIABLE FOR ANY SPECIAL, DIRECT,  INDIRECT, OR CONSEQUENTIAL
@c DAMAGES OR ANY DAMAGES WHATSOEVER  RESULTING FROM LOSS OF USE, DATA OR
@c PROFITS,  WHETHER  IN  AN  ACTION  OF CONTRACT,  NEGLIGENCE  OR  OTHER
@c TORTIOUS  ACTION, ARISING  OUT OF  OR IN  CONNECTION WITH  THE  USE OR
@c PERFORMANCE OF THIS SOFTWARE.
@c
@c                                      Anthony Mallet on Fri Jun 25 2010
@c

@node C++ Scoped name
@subsection Scoped names

The @code{C++} mappings for scoped names use C++ scopes.  IDL
@code{module}s are mapped to @code{namespace}s. For instance, the
following IDL:
@verbatim
      module m {
         const string str = "scoped string";
      };
@end verbatim

would map into
@verbatim
      namespace m {
         const std::string str = "scoped string";
      }
@end verbatim


@node C++ Constant
@subsection Mapping for constants

@genom{} IDL constants are mapped to a @code{C++} constant. For
instance, the following @acronym{IDL}:
@verbatim
   const long longint = 1;
   const string str = "string example";
@end verbatim

would map into
@verbatim
   const int32_t longint = 1;
   const std::string str = "string example";
@end verbatim


@node C++ Basic type
@subsection Mapping for basic data types

The basic data types have the mappings shown in the table below.
Integer types use the @code{C99} fixed size integer types as provided
by the @code{stdint.h} standard header (since the C++ @code{cstdint}
header is not part of the C++ at the time of writing this document).
Users do not have to include this header: the template mapping
generation procedure output the appropriate @code{#include} directive
along with the mappings for the integer types.

@float Table
@multitable @columnfractions 0.4 0.4
@headitem @code{IDL}
@tab @code{C++}
@item @code{boolean}
@tab @code{bool}
@item @code{unsigned short}
@tab @code{uint16_t}
@item @code{short}
@tab @code{int16_t}
@item @code{unsigned long}
@tab @code{uint32_t}
@item @code{long}
@tab @code{int32_t}
@item @code{unsigned long long}
@tab @code{uint64_t}
@item @code{long long}
@tab @code{int64_t}
@item @code{float}
@tab @code{float}
@item @code{double}
@tab @code{double}
@item @code{char}
@tab @code{int8_t}
@item @code{octet}
@tab @code{uint8_t}
@item @code{any}
@tab type any not implemented yet
@end multitable
@caption{Basic data types mappings in C++}
@end float


@node C++ Enumerated type
@subsection Mapping for enumerated types

The C++ mapping of an IDL @code{enum} type is the corresponding C++
@code{enum}. An additional constant is generated to guarantee that the
type occupies a 32 bits wide integer.

For instance, the following IDL:
@verbatim
      enum e {
         value1,
         value2
      };
@end verbatim

would map, according to the scoped names rules, into
@verbatim
      enum e {
         value1,
         value2,
         _unused = 0xffffffff,
      };
@end verbatim

@node C++ String
@subsection Mapping for strings

@genom{} IDL bounded strings are mapped to nul terminated character
arrays (i.e., C strings). Unbounded strings are mapped to
@code{std::string} provided by the C++ standard.

For instance, the following OMG IDL declarations:
@verbatim
      typedef string unbounded;
      typedef string<16> bounded;
@end verbatim

would map into
@verbatim
      typedef std::string unbounded;
      typedef char bounded[16];
@end verbatim


@node C++ Array
@subsection Mapping for arrays

@genom{} IDL arrays map directly to C++ arrays. All array indices run from 0 to
@code{size-1}.

For instance, the following IDL:
@verbatim
      typedef long array[4][16];
@end verbatim

would map into
@verbatim
      typedef int32_t array[4][16];
@end verbatim

@node C++ Struct
@subsection Mapping for structure types

@genom{} IDL  structures map directly onto  C++ @code{struct}s.  Note that these
structures may potentially include padding.

For instance, the following IDL:
@verbatim
      struct s {
         long a;
         long b;
      };
@end verbatim

would map into
@verbatim
      struct s {
         int32_t a;
         int32_t b;
      };
@end verbatim


@node C++ Union
@subsection Mapping for union types

@genom{} IDL unions map onto C  @code{struct}s. The discriminator in the enum is
referred to as  @code{_d}, the union  itself is referred to as  @code{_u}.

For instance, the following IDL:
@verbatim
      union u switch(long) {
         case 1: long a;
         case 2: float b;
         default: char c;
      };
@end verbatim

would map into
@verbatim
      struct u {
         int32_t _d;
         union {
            int32_t a;
            float b;
            char c;
         } _u;
      };
@end verbatim

Note that the C++ standard does not allow union members that have a
non-trivial constructor.  Consequently, the C++ mapping for such kind
of unions is not allowed in @genom{} either. This concerns
@code{sequence}s and @code{string}s, and structures or unions that
contain such a type. You should thus avoid to define such datatypes in
@genom{} IDL in order to maximize the portability of your definitions.

@node C++ Sequence
@subsection Mapping for sequence types

@genom{} IDL sequences mapping differ for bounded or unbouded
variations of the sequence. The bounded sequences maps onto the
@code{std::vector} template class provided by the C++ standard.  The
unbounded sequence maps onto a C++ @code{std::tr1::array} template
class. The definition of @code{std::tr1::array} is not provided by the
C++ standard, but is commonly implemented by modern C++ compiler as a
transition step toward the C++11 standard.

For instance, the following IDL:
@verbatim
      typedef sequence<long> unbounded;
      typedef sequence<long,16> bounded;
@end verbatim

would map into
@verbatim
      typedef std::vector<int32_t> unbounded;
      typedef std::tr1::array<int32_t, 16> bounded;
@end verbatim

At the time of writing, @code{std::array} is still not officially
supported by most compilers and available only as an experimental
extension, so it has been decided to not use it. As soon as most
compilers will provide an official implementation of
@code{std::array}, this type will be used instead of
@code{std::tr1::array}. Since the differences between the two
interfaces are minimal, this should have only little impact on
existing code.


@node C++ Port
@subsection Mapping for port types

Simple ports map onto a pure virtual @code{struct} providing a
@code{data()} and @code{read()} or @code{write()} methods. The
@code{data()} method takes no parameter and returns a constant
reference on the current port data. Input ports may refresh their data
by invoking the @code{read()} method, while output ports may publish
new data by invoking the @code{write()} method. Both @code{read()} and
@code{write()} return no value (@code{void}).

Ports defined with the @code{multiple} flag map onto a similar
pure virtual @code{struct}, with the difference that @code{data()},
@code{read()} and @code{write()} methods take an additional string
(@code{const char *}) parameter representing the port element
name. Multiple output ports have two additional @code{open()} and
@code{close()} members (also accepting a single string parameter) that
dynamically create or destroy ports.

All these method may throw a @code{genom::exception} representing an
error code.

For instance, the following IDL:
@verbatim
      port in double in_port;
      port multiple in double multi_in_port;
      port out double out_port;
      port multiple out double multi_out_port;
@end verbatim

would map into
@verbatim
      struct in_port {
         virtual const double &data(void) const = 0;
         virtual void read(void) = 0;
      };

      struct multi_in_port {
         virtual const double &data(const char *id) const = 0;
         virtual void read(const char *id) = 0;
      };

      struct out_port {
         virtual double &data(void) const = 0;
         virtual void write(void) = 0;
      };

      struct multi_out_port {
         virtual double &data(const char *id) const = 0;
         virtual void write(const char *id) = 0;
         virtual void open(const char *id) = 0;
         virtual void close(const char *id) = 0;
      };
@end verbatim


@node C++ Remote
@subsection Mapping for remote services

Remote objects map onto a pure virtual @code{struct} providing a
@code{call()} method. @code{call()} takes the same parameters as the
corresponing service definition and return no data (@code{void}). It
may throw a @code{genom::exception} representing an error code.

For instance, the following IDL:
@verbatim
      interface i {
        function f(in long i, out double o);
      };

      component c {
        uses i;
      };
@end verbatim

would map into
@verbatim
      namespace c {
        struct f {
          virtual void call(uint32_t i, double &o) = 0;
        };
      }
@end verbatim

The remote service is invoked in a synchronous manner.


@node C++ Native
@subsection Mapping for native types

@genom{} IDL native types map to a C++ @code{struct}. The mapping
provides only a forward declaration, and the user has to provide the
actual definition.

For instance, the following IDL:
@verbatim
      native opaque;
@end verbatim

would map into
@verbatim
      struct opaque;
@end verbatim

The definition of the structure body is free, and will typically use
native C++ types that cannot be described in IDL. When used as a
parameter of a function, a native type will be passed around as a
pointer on the structure data. Memory management associated with that
pointer must be handled by the user.


@node C++ Exception
@subsection Mapping for exceptions

Each defined exception type is defined as a C++ @code{struct} that
derives from the generic @code{genom::exception} type and implements a
@code{what()} method returning a unique identifier for the
exception. Exceptions with members define an additional @code{struct
detail} type inside the scope of the exception as well a a
@code{detail} member of that type. A global identifier for the
exception is also defined (it is identical to the return value of the
@code{what} method).

For example:
@verbatim
      exception foo {
        long dummy;
      };
@end verbatim

yields the following C++ declarations:
@verbatim
      genom_event foo_id = <unique identifier for exception>;

      struct foo : public genom::exception {
        struct detail {
          uint32_t dummy;
        } detail;

        const char *what();
      } foo_detail;
@end verbatim

Exceptions must be thrown with the C++ @code{throw} operator.

The identifier for the exception uniquely identifies this exception
type, so that any data of type @code{genom_event} can be compared to
an exception id with the @code{==} operator.
